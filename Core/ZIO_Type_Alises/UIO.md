# UIO

`UIO[A]` 는 `ZIO[Any, Nothing, A]` 의 타입 별칭이다.</br>
이는 어떤 환경이든 상관없고, **실패하지 않으며** `A` 로 성공하는 이펙트를 나타낸다.

> ### NOTE
> 스칼라에서 _타입 별칭_이란 원본 타입을 매번 반복하는 것을 피하기 위해 다른 타입에 이름을 주는 방법이다.</br>
> 이는 타입 검사 과정에는 영향을 끼치지 않고, 더 풍부한 API 디자인을 도와준다.

`UIO` 타입 정의:
```scala
type UIO[+A] = ZIO[Any, Nothing, A]
```

따라서 `UIO` 는</br>
**어떤 환경도 필요없고**(`Any` 환경이므로)</br>
**실패하지 않는**(스칼라에서 `Nothing` 타입의 실제 값은 있을 수 없다.)</br>
`ZIO` 와 동일하며, `A` 로 성공한다.

`UIO[A]` 타입의 `ZIO` 값은 _실패하지 않는_ 값으로 간주된다. `A` 를 생산하지만 절대 실패하지 않는다.

피보나치 함수를 작성해 보자.</br>
예제를 보면, `fib` 함수는 실패하지 않고 `Int` 타입으로 성공하는 이펙트이다:
```scala mdoc:reset:silent
import zio.{UIO, ZIO}

def fib(n: Int): UIO[Int] =
  if (n <= 1) {
    ZIO.succeed(1)
  } else {
    for {
      fiber1 <- fib(n - 2).fork
      fiber2 <- fib(n - 1).fork
      v2     <- fiber2.join
      v1     <- fiber1.join
    } yield v1 + v2
  }
```

> ### Principle of The Least Power
> `ZIO` 데이터 타입은 ZIO 라이브러리에서 가장 강력한 이펙트이다. 이는 워크플로우의 다양한 타입들을 모델링하게 도와준다.</br>
> 반면에 타입 별칭은 `ZIO` 타입을 좀 더 전문화하고, 하위 유형으로 변환한다. 이는 조금 덜 강력한 워크플로에 적합하다.
>
> 대부분의 경우 `ZIO`의 강력한 기능은 필요하지 않다. 따라서 일반적으로 덜 강력한 이펙트가 필요할 때마다 타입 별칭으로 적절한 전문화를 하는게 좋다.</br>
> 
> 따라서 `ZIO` 데이터 타입이 필요할 때마다 타입 별칭을 `ZIO` 로 변환할 필요가 없고, 각각의 워크플로가 필요로 하는 가장 적절한 타입 별칭을 사용하면 된다.